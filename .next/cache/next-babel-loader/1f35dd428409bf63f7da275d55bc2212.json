{"ast":null,"code":"var _jsxFileName = \"/home/doublebridges/projects/next-example/lib/user.js\";\nvar __jsx = React.createElement;\nimport React from 'react';\nimport fetch from 'isomorphic-unfetch'; // Use a global to save the user, so we don't have to fetch it again after page navigations\n\nlet userState;\nconst User = React.createContext({\n  user: null,\n  loading: false\n});\nexport const fetchUser = async () => {\n  if (userState !== undefined) {\n    return userState;\n  }\n\n  const res = await fetch('/api/me');\n  userState = res.ok ? await res.json() : null;\n  console.log(userState);\n  return userState;\n};\nexport const UserProvider = ({\n  value,\n  children\n}) => {\n  const {\n    user\n  } = value; // If the user was fetched in SSR add it to userState so we don't fetch it again\n\n  React.useEffect(() => {\n    if (!userState && user) {\n      userState = user;\n    }\n  }, []);\n  return __jsx(User.Provider, {\n    value: value,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 30\n    },\n    __self: this\n  }, children);\n};\nexport const useUser = () => React.useContext(User);\nexport const useFetchUser = () => {\n  const [data, setUser] = React.useState({\n    user: userState || null,\n    loading: userState === undefined\n  });\n  React.useEffect(() => {\n    if (userState !== undefined) {\n      return;\n    }\n\n    let isMounted = true;\n    fetchUser().then(user => {\n      // Only set the user if the component is still mounted\n      if (isMounted) {\n        setUser({\n          user,\n          loading: false\n        });\n      }\n    });\n    return () => {\n      isMounted = false;\n    };\n  }, [userState]);\n  return data;\n};","map":{"version":3,"sources":["/home/doublebridges/projects/next-example/lib/user.js"],"names":["React","fetch","userState","User","createContext","user","loading","fetchUser","undefined","res","ok","json","console","log","UserProvider","value","children","useEffect","useUser","useContext","useFetchUser","data","setUser","useState","isMounted","then"],"mappings":";;AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,KAAP,MAAkB,oBAAlB,C,CAEA;;AACA,IAAIC,SAAJ;AAEA,MAAMC,IAAI,GAAGH,KAAK,CAACI,aAAN,CAAoB;AAAEC,EAAAA,IAAI,EAAE,IAAR;AAAcC,EAAAA,OAAO,EAAE;AAAvB,CAApB,CAAb;AAEA,OAAO,MAAMC,SAAS,GAAG,YAAY;AACnC,MAAIL,SAAS,KAAKM,SAAlB,EAA6B;AAC3B,WAAON,SAAP;AACD;;AAED,QAAMO,GAAG,GAAG,MAAMR,KAAK,CAAC,SAAD,CAAvB;AACAC,EAAAA,SAAS,GAAGO,GAAG,CAACC,EAAJ,GAAS,MAAMD,GAAG,CAACE,IAAJ,EAAf,GAA4B,IAAxC;AACAC,EAAAA,OAAO,CAACC,GAAR,CAAYX,SAAZ;AACA,SAAOA,SAAP;AACD,CATM;AAWP,OAAO,MAAMY,YAAY,GAAG,CAAC;AAAEC,EAAAA,KAAF;AAASC,EAAAA;AAAT,CAAD,KAAyB;AACnD,QAAM;AAAEX,IAAAA;AAAF,MAAWU,KAAjB,CADmD,CAGnD;;AACAf,EAAAA,KAAK,CAACiB,SAAN,CAAgB,MAAM;AACpB,QAAI,CAACf,SAAD,IAAcG,IAAlB,EAAwB;AACtBH,MAAAA,SAAS,GAAGG,IAAZ;AACD;AACF,GAJD,EAIG,EAJH;AAMA,SAAO,MAAC,IAAD,CAAM,QAAN;AAAe,IAAA,KAAK,EAAEU,KAAtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAA8BC,QAA9B,CAAP;AACD,CAXM;AAaP,OAAO,MAAME,OAAO,GAAG,MAAMlB,KAAK,CAACmB,UAAN,CAAiBhB,IAAjB,CAAtB;AAEP,OAAO,MAAMiB,YAAY,GAAG,MAAM;AAChC,QAAM,CAACC,IAAD,EAAOC,OAAP,IAAkBtB,KAAK,CAACuB,QAAN,CAAe;AACrClB,IAAAA,IAAI,EAAEH,SAAS,IAAI,IADkB;AAErCI,IAAAA,OAAO,EAAEJ,SAAS,KAAKM;AAFc,GAAf,CAAxB;AAKAR,EAAAA,KAAK,CAACiB,SAAN,CAAgB,MAAM;AACpB,QAAIf,SAAS,KAAKM,SAAlB,EAA6B;AAC3B;AACD;;AAED,QAAIgB,SAAS,GAAG,IAAhB;AAEAjB,IAAAA,SAAS,GAAGkB,IAAZ,CAAiBpB,IAAI,IAAI;AACvB;AACA,UAAImB,SAAJ,EAAe;AACbF,QAAAA,OAAO,CAAC;AAAEjB,UAAAA,IAAF;AAAQC,UAAAA,OAAO,EAAE;AAAjB,SAAD,CAAP;AACD;AACF,KALD;AAOA,WAAO,MAAM;AACXkB,MAAAA,SAAS,GAAG,KAAZ;AACD,KAFD;AAGD,GAjBD,EAiBG,CAACtB,SAAD,CAjBH;AAmBA,SAAOmB,IAAP;AACD,CA1BM","sourcesContent":["import React from 'react';\nimport fetch from 'isomorphic-unfetch';\n\n// Use a global to save the user, so we don't have to fetch it again after page navigations\nlet userState;\n\nconst User = React.createContext({ user: null, loading: false });\n\nexport const fetchUser = async () => {\n  if (userState !== undefined) {\n    return userState;\n  }\n\n  const res = await fetch('/api/me');\n  userState = res.ok ? await res.json() : null;\n  console.log(userState);\n  return userState;\n};\n\nexport const UserProvider = ({ value, children }) => {\n  const { user } = value;\n\n  // If the user was fetched in SSR add it to userState so we don't fetch it again\n  React.useEffect(() => {\n    if (!userState && user) {\n      userState = user;\n    }\n  }, []);\n\n  return <User.Provider value={value}>{children}</User.Provider>;\n};\n\nexport const useUser = () => React.useContext(User);\n\nexport const useFetchUser = () => {\n  const [data, setUser] = React.useState({\n    user: userState || null,\n    loading: userState === undefined\n  });\n\n  React.useEffect(() => {\n    if (userState !== undefined) {\n      return;\n    }\n\n    let isMounted = true;\n\n    fetchUser().then(user => {\n      // Only set the user if the component is still mounted\n      if (isMounted) {\n        setUser({ user, loading: false });\n      }\n    });\n\n    return () => {\n      isMounted = false;\n    };\n  }, [userState]);\n\n  return data;\n};\n"]},"metadata":{},"sourceType":"module"}